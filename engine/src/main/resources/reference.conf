# Reference configuration for the DataStax Loader.
#
# All the values declared here will be used as defaults if you don't override them through
# command line arguments.
#
# This file is in HOCON format, see https://github.com/typesafehub/config/blob/master/HOCON.md.
datastax-loader {

  driver {

    # The contact points to use for the initial connection to the cluster.
    #
    # These are addresses of Cassandra nodes that the driver uses to discover the cluster topology.
    # Only one contact point is required (the driver will retrieve the address of the other nodes
    # automatically), but it is usually a good idea to provide more than one contact point, because
    # if that single contact point is unavailable, the driver cannot initialize itself correctly.
    #
    # This must be a list of strings with each contact point specified as "host:port". If the host is
    # a DNS name that resolves to multiple A-records, all the corresponding addressess will be used.
    # Do not use "localhost" as the host name (since it resolves to both IPv4 and IPv6 addresses on
    # some platforms).
    #
    # Note that the current version of Cassandra (3.11) requires all nodes in a cluster to share the
    # same port.
    contact-points = ["127.0.0.1:9042"]

    protocol {

      # The native protocol version to use.
      #
      # This option is not required. If it is absent, the driver will negotiate it with the *first*
      # node it tries to connect to. More precisely, it will try with the highest supported version,
      # and if not supported fallback to the second highest and so on.
      # Once the version is set, it will be used for the lifetime of the driver instance.
      # Auto detection can be problematic with mixed-version clusters: if the driver connects first
      # to one of the higher-version nodes, it will negotiate a version that might not work when
      # connecting to lower-version nodes later. You should force the lowest common protocol version
      # in that case.
      version = V4

      # Compression
      compression = LZ4

    }

    # The driver maintains a connection pool to each node, according to the distance assigned to it
    # by the load balancing policy. If the distance is IGNORED, no connections are maintained.
    pooling {

      local {

        # The number of connections in the pool.
        connections = 1

        # The maximum number of requests that can be executed concurrently on a connection.
        # This must be between 1 and 32768.
        requests = 32768

      }

      remote {

        # The number of connections in the pool.
        connections = 1

        # The maximum number of requests that can be executed concurrently on a connection.
        # This must be between 1 and 32768.
        requests = 1024

      }

      # The heartbeat interval. If a connection stays idle for that duration (no reads), the driver
      # sends a dummy message on it to make sure it's still alive. If not, the connection is
      # trashed and replaced.
      heartbeat = 30 seconds

    }

    query {

      # The consistency level.
      consistency = LOCAL_ONE

      # The serial consistency level.
      # The allowed values are SERIAL and LOCAL_SERIAL.
      serial-consistency = LOCAL_SERIAL

      # The page size. This controls how many rows will be retrieved simultaneously in a single
      # network roundtrip (the goal being to avoid loading too many results in memory at the same
      # time).
      fetch-size = 5000

      # The default idempotence of a request.
      idempotence = true

    }

    socket {

      # How long the driver waits for a request to complete. This is a global limit on the duration
      # of a session.execute() call, including any internal retries the driver might do.
      read-timeout = 12 seconds

    }

    # The auth provider that will handle authentication for each new connection to a server.
    auth {

      # This property is optional; if it is not present, no authentication will occur.
      # provider =

      # Sample configuration for the plain-text provider:
      // username = cassandra
      // password = cassandra

    }

    # The SSL engine factory that will initialize an SSL engine for each new connection to a server.
    ssl {

      # This property is optional; if it is not present, SSL won't be activated.
      # engine-factory =

      # Sample configuration for the default SSL factory:
      # The cipher suites to enable when creating an SSLEngine for a connection.
      # This property is optional. If it is not present, the driver won't explicitly enable cipher
      # suites on the engine, which according to the JDK documentations results in "a minimum
      # quality of service".
      // cipher-suites = [ "TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA" ]
      # cipher-suites = []

    }

    # The generator that assigns a microsecond timestamp to each query sent by the driver.
    # The implementation to use. Built-in options are (all from the package
    # com.datastax.oss.driver.api.core.time):
    # - AtomicTimestampGenerator: timestamps are guaranteed to be unique across all client threads.
    # - ThreadLocalTimestampGenerator: timestamps that are guaranteed to be unique within each
    #   thread only.
    # - ServerSideTimestampGenerator: do not generate timestamps, let the server assign them.
    timestamp-generator = com.datastax.driver.core.AtomicMonotonicTimestampGenerator

    # The address translator to use to convert the addresses sent by Cassandra nodes into ones that
    # the driver uses to connect.
    # This is only needed if the nodes are not directly reachable from the driver (for example, the
    # driver is in a different network region and needs to use a public IP, or it connects through
    # a proxy).
    address-translator = com.datastax.driver.core.policies.IdentityTranslator

    policy {

      retry = com.datastax.driver.core.policies.DefaultRetryPolicy

      lbp = com.datastax.driver.core.policies.RoundRobinPolicy

      specexec = com.datastax.driver.core.policies.NoSpeculativeExecutionPolicy

    }

  }

  batch {

    mode = UNSORTED

    buffer-size = 1000

  }

  executor {

    max-threads = 4C

    max-inflight = 1000

    max-per-second = 100000

    continuous-paging {

      page-unit = ROWS

      page-size = 5000

      max-pages = 0

      max-pages-per-second = 0

    }

  }

  log {

    output-directory = "file:."

    max-threads = 4

    # -1 means no maximum
    max-errors = 100

    stmt {

      verbosity = EXTENDED

      max-query-string-length = 500

      max-bound-values = 50

      max-bound-value-length = 50

      max-inner-statements = 10

    }
  }

  codec {

    locale = en_US

    time-zone = UTC

    # ALl possible combinations for true:false (case insensitive); the first combination is considered the default
    # and used when formatting.
    boolean = [ "1:0", "Y:N", "T:F", "YES:NO", "TRUE:FALSE" ]

    number = "#,###.##"

    # Can be a pattern, a static public field in DateTimeFormatter (such as "ISO_DATE_TIME")
    # or the value "CQL_DATE_TIME" which means "accept all valid CQL formats"
    timestamp = "CQL_DATE_TIME"

    # Can be a pattern, a static public field in DateTimeFormatter (such as "ISO_LOCAL_DATE")
    date = "ISO_LOCAL_DATE"

    # Can be a pattern, a static public field in DateTimeFormatter (such as "ISO_LOCAL_TIME")
    time = "ISO_LOCAL_TIME"

  }
}
